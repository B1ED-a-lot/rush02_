# üõ°Ô∏è GUIA DE SOBREVIV√äNCIA - RUSH 02

## üìã CHECKLIST DE ERROS (Para n√£o esquecer nada!)

### Erros que devem retornar "Error\n":

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        CHECKLIST DE VALIDA√á√ÉO                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ [ ] argc != 2 e argc != 3 (espera 1 ou 2 argumentos)                       ‚îÇ
‚îÇ [ ] String vazia ""                                                        ‚îÇ
‚îÇ [ ] N√∫mero com letras "42a", "abc"                                         ‚îÇ
‚îÇ [ ] N√∫mero negativo "-42"                                                  ‚îÇ
‚îÇ [ ] N√∫mero com sinal "+" ‚Üí "+42"                                           ‚îÇ
‚îÇ [ ] N√∫mero decimal "42.5"                                                  ‚îÇ
‚îÇ [ ] N√∫mero com espa√ßos " 42", "4 2"                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Erros que devem retornar "Dict Error\n":

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     CHECKLIST DE ERROS DO DICION√ÅRIO                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ [ ] Arquivo n√£o existe ou n√£o pode ser aberto                              ‚îÇ
‚îÇ [ ] Linha sem ':' no dicion√°rio                                            ‚îÇ
‚îÇ [ ] Chave (key) vazia ou s√≥ espa√ßos                                        ‚îÇ
‚îÇ [ ] Chave com caracteres n√£o-num√©ricos                                     ‚îÇ
‚îÇ [ ] Falta uma chave necess√°ria para a convers√£o                            ‚îÇ
‚îÇ     (ex: converter 50 mas n√£o tem "50" nem "5" + "0")                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üß™ TESTES PARA FAZER ANTES DE ENTREGAR

### Testes B√°sicos:

```bash
# N√∫meros simples (0-19)
./rush-02 0          # Esperado: zero
./rush-02 1          # Esperado: one
./rush-02 10         # Esperado: ten
./rush-02 15         # Esperado: fifteen
./rush-02 19         # Esperado: nineteen

# Dezenas (20-99)
./rush-02 20         # Esperado: twenty
./rush-02 42         # Esperado: forty two
./rush-02 99         # Esperado: ninety nine

# Centenas (100-999)
./rush-02 100        # Esperado: one hundred
./rush-02 101        # Esperado: one hundred one
./rush-02 234        # Esperado: two hundred thirty four
./rush-02 999        # Esperado: nine hundred ninety nine
```

### Testes de Milhares:

```bash
./rush-02 1000       # Esperado: one thousand
./rush-02 1001       # Esperado: one thousand one
./rush-02 1234       # Esperado: one thousand two hundred thirty four
./rush-02 10000      # Esperado: ten thousand
./rush-02 100000     # Esperado: one hundred thousand
./rush-02 999999     # Esperado: nine hundred ninety nine thousand nine hundred ninety nine
```

### Testes de Milh√µes e Al√©m:

```bash
./rush-02 1000000    # Esperado: one million
./rush-02 1234567    # Esperado: one million two hundred thirty four thousand five hundred sixty seven
./rush-02 1000000000 # Esperado: one billion
```

### Testes de Erro:

```bash
./rush-02            # Esperado: Error (argc = 1)
./rush-02 ""         # Esperado: Error (string vazia)
./rush-02 "42a"      # Esperado: Error (letra no n√∫mero)
./rush-02 "-42"      # Esperado: Error (n√∫mero negativo)
./rush-02 "42.5"     # Esperado: Error (decimal)
./rush-02 " 42"      # Esperado: Error (espa√ßo antes)
./rush-02 inexistente.txt 42  # Esperado: Dict Error (arquivo n√£o existe)
```

### Testes com Dicion√°rio Customizado:

```bash
# Crie um arquivo test.dict com:
# 20 : vinte
# 2 : dois

./rush-02 test.dict 22   # Esperado: vinte dois
```

### Teste de Formata√ß√£o:

```bash
# Verificar se output termina corretamente
./rush-02 42 | cat -e
# Esperado: forty two$ ($ indica fim de linha)

# N√ÉO deve ter espa√ßos extras:
./rush-02 42 | wc -c
# "forty two\n" = 10 caracteres
```

---

## üéì COMO EXPLICAR O C√ìDIGO NA AVALIA√á√ÉO

### 1. Explique o FLUXO GERAL:

```
"O programa funciona em 4 etapas principais:

1. VALIDA√á√ÉO: Verifica se os argumentos s√£o v√°lidos
   - argc deve ser 2 ou 3
   - O n√∫mero deve conter apenas d√≠gitos

2. PARSING: L√™ o dicion√°rio e cria uma lista ligada
   - Abre o arquivo com open()
   - L√™ o conte√∫do com read()
   - Para cada linha, separa key e value
   - Armazena em uma struct t_dict

3. CONVERS√ÉO: Transforma o n√∫mero em texto
   - Usa decomposi√ß√£o: milh√µes, milhares, centenas, dezenas, unidades
   - Busca cada parte no dicion√°rio

4. LIMPEZA: Libera toda a mem√≥ria alocada
   - free_dict() percorre a lista e libera cada n√≥"
```

### 2. Se perguntarem sobre DECOMPOSI√á√ÉO:

```
"Para converter 1234:

1. Quantos d√≠gitos? 4 ‚Üí √© milhares
2. 1234 / 1000 = 1 ‚Üí 'one'
3. Busca 1000 no dict ‚Üí 'thousand'
4. 1234 % 1000 = 234 ‚Üí resto para processar
5. 234 / 100 = 2 ‚Üí 'two'
6. Busca 100 no dict ‚Üí 'hundred'
7. 234 % 100 = 34 ‚Üí resto
8. 34 busca direto? N√£o tem
9. 34 / 10 = 3 ‚Üí 30 ‚Üí 'thirty'
10. 34 % 10 = 4 ‚Üí 'four'

Resultado: 'one thousand two hundred thirty four'"
```

### 3. Se perguntarem sobre LISTA LIGADA:

```
"Usamos lista ligada porque:

1. N√£o sabemos quantas linhas tem o dicion√°rio
2. Podemos adicionar entradas conforme lemos
3. Cada n√≥ tem: key (n√∫mero como string), value (texto), next (pr√≥ximo)

Visualmente:
[0|zero|‚Üí] ‚Üí [1|one|‚Üí] ‚Üí [42|forty two|‚Üí] ‚Üí NULL"
```

### 4. Se perguntarem sobre MEM√ìRIA:

```
"Temos um rigoroso controle de mem√≥ria:

ALOCAMOS em:
- read_file(): conte√∫do do arquivo
- parse_line(): cada n√≥, key e value
- ft_strdup(), ft_strjoin(), etc.

LIBERAMOS em:
- parse_dict(): libera content ap√≥s usar
- free_dict(): libera cada n√≥, key, value
- main(): chama free_dict() no final

Posso rodar valgrind/leaks para provar!"
```

### 5. Se perguntarem sobre CASOS ESPECIAIS:

```
"Tratamos v√°rios casos:

1. Zero: busca direto '0' ‚Üí 'zero'
2. Zeros √† esquerda: '007' ‚Üí pula zeros ‚Üí '7' ‚Üí 'seven'
3. Zeros no meio: '1001' ‚Üí 'one thousand one' (sem 'zero' no meio)
4. N√∫meros muito grandes: trabalhamos com strings, n√£o int
5. Espa√ßos no dict: trim remove antes de usar"
```

---

## üìÅ ESTRUTURA DO PROJETO

```
ex00/
‚îú‚îÄ‚îÄ Makefile
‚îú‚îÄ‚îÄ includes/
‚îÇ   ‚îî‚îÄ‚îÄ ft_rush02.h          # Header com structs e prot√≥tipos
‚îú‚îÄ‚îÄ srcs/
‚îÇ   ‚îú‚îÄ‚îÄ main.c               # Ponto de entrada, valida√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ ft_dict_parsing.c    # Leitura e parsing do dicion√°rio
‚îÇ   ‚îú‚îÄ‚îÄ ft_dict_utils.c      # Manipula√ß√£o da lista ligada
‚îÇ   ‚îú‚îÄ‚îÄ ft_number_converter.c # L√≥gica de convers√£o
‚îÇ   ‚îî‚îÄ‚îÄ ft_utils.c           # Fun√ß√µes auxiliares b√°sicas
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îî‚îÄ‚îÄ numbers.dict         # Dicion√°rio padr√£o
‚îî‚îÄ‚îÄ Guias_de_Estudo/
    ‚îú‚îÄ‚îÄ algoritmo_decomposicao.md
    ‚îú‚îÄ‚îÄ gerenciamento_memoria.md
    ‚îú‚îÄ‚îÄ funcoes_novas.md
    ‚îî‚îÄ‚îÄ guia_de_sobrevivencia_rush02.md
```

---

## üìã NORMA V4.1 - LEMBRETES

### Regras Cr√≠ticas:

```
[ ] Fun√ß√µes com no m√°ximo 25 linhas
[ ] No m√°ximo 5 fun√ß√µes por arquivo .c
[ ] No m√°ximo 5 vari√°veis por fun√ß√£o
[ ] No m√°ximo 4 par√¢metros por fun√ß√£o
[ ] Vari√°veis declaradas no in√≠cio da fun√ß√£o
[ ] Uma linha vazia entre declara√ß√µes e c√≥digo
[ ] Cabe√ßalho 42 em todos os arquivos
```

### Nomenclatura:

```
[ ] struct come√ßa com s_  (ex: struct s_dict)
[ ] typedef come√ßa com t_ (ex: t_dict)
[ ] Vari√°veis em snake_case (ex: bytes_read)
[ ] Fun√ß√µes em snake_case (ex: parse_dict)
```

### Proibi√ß√µes:

```
[ ] N√ÉO usar: for, do...while, switch, case, goto
[ ] N√ÉO usar: tern√°rio (?:)
[ ] N√ÉO usar: VLAs (int arr[n])
[ ] N√ÉO usar: printf, atoi, ou fun√ß√µes n√£o autorizadas
```

---

## üîß COMPILA√á√ÉO E DEBUG

### Compilar:

```bash
make          # Compila o projeto
make clean    # Remove .o
make fclean   # Remove .o e execut√°vel
make re       # Recompila tudo
```

### Debug com prints (REMOVER antes de entregar!):

```c
// Use write para stderr (fd=2) para n√£o misturar com output
write(2, "DEBUG: aqui\n", 12);

// Para ver valores num√©ricos, crie uma fun√ß√£o tempor√°ria:
void debug_num(int n)
{
    char c;
    if (n >= 10)
        debug_num(n / 10);
    c = '0' + (n % 10);
    write(2, &c, 1);
}
```

### Verificar Memory Leaks:

```bash
# Linux
valgrind --leak-check=full ./rush-02 42

# macOS
leaks -atExit -- ./rush-02 42
```

---

## üöÄ DIVIS√ÉO DE TAREFAS NO GRUPO

### Sugest√£o para 3 pessoas:

```
PESSOA 1: Parsing (ft_dict_parsing.c + ft_dict_utils.c)
- Implementar read_file()
- Implementar parse_line()
- Implementar parse_dict()
- Implementar dict_add_back(), dict_search()
- Implementar free_dict()

PESSOA 2: Convers√£o (ft_number_converter.c)
- Implementar is_valid_number()
- Implementar print_small_number()
- Implementar convert_number()
- L√≥gica de decomposi√ß√£o

PESSOA 3: Base (main.c + ft_utils.c)
- Implementar main() com valida√ß√µes
- Implementar ft_putchar(), ft_putstr()
- Implementar ft_strlen(), ft_strcmp()
- Implementar ft_strdup(), ft_isdigit()
- Implementar ft_strtrim_spaces()
- Ajudar com fun√ß√µes auxiliares extras (ft_substr, ft_strjoin)
```

### Dica de Integra√ß√£o:

```
1. Primeiro: fun√ß√µes b√°sicas (ft_utils.c)
2. Depois: parsing do dicion√°rio
3. Por √∫ltimo: convers√£o

Testem cada parte ANTES de juntar!
```

---

## ‚è∞ CRONOGRAMA SUGERIDO (48h)

### Dia 1 (S√°bado):

```
Manh√£ (4h):
- Ler e entender o subject completamente
- Planejar a divis√£o de tarefas
- Configurar o reposit√≥rio git

Tarde (4h):
- Implementar ft_utils.c (todos juntos para entender)
- Testar cada fun√ß√£o isoladamente

Noite (4h):
- Come√ßar o parsing (read_file, parse_line)
- Come√ßar a valida√ß√£o do n√∫mero
```

### Dia 2 (Domingo):

```
Manh√£ (4h):
- Terminar parsing
- Terminar is_valid_number
- Testar parsing com dicion√°rio simples

Tarde (4h):
- Implementar l√≥gica de convers√£o
- Come√ßar com casos simples (0-99)

Noite (4h):
- Implementar casos maiores (100+, 1000+)
- Integrar tudo no main
- Testes extensivos
```

### Segunda (√öltima hora):

```
- Remover TODOS os prints de debug
- Verificar Norma
- Testar todos os casos
- Verificar memory leaks
- REVISAR o c√≥digo em grupo (todos devem entender tudo!)
```

---

## üÜò PROBLEMAS COMUNS E SOLU√á√ïES

### Problema: Segmentation Fault
```
Causas comuns:
- Acesso a ponteiro NULL
- Acesso fora dos limites do array
- Uso de mem√≥ria ap√≥s free

Solu√ß√£o:
- Sempre verifique if (!ptr) antes de usar
- Use prints de debug para encontrar onde crashou
```

### Problema: Output com formato errado
```
Sintoma: "forty  two" (dois espa√ßos)
Causa: Imprimindo espa√ßo quando n√£o deveria

Solu√ß√£o: Verifique condi√ß√µes antes de ft_putchar(' ')
```

### Problema: Memory Leak
```
Sintoma: valgrind mostra bytes n√£o liberados

Solu√ß√£o:
- Verifique se free_dict est√° correto
- Verifique se libera temp em loops de strjoin
- Verifique se libera content ap√≥s parse_dict
```

### Problema: Dict Error quando n√£o deveria
```
Causa: parse_line rejeitando linhas v√°lidas

Solu√ß√£o:
- Verifique se est√° fazendo trim correto
- Verifique se encontra ':' corretamente
- Print debug do que est√° parseando
```

---

**BOA SORTE NA AVALIA√á√ÉO! üöÄ**

*"O grupo que treina junto, vence junto!"*

---

## üìå CONTATOS √öTEIS

- Slack/Discord do grupo: _____________
- Hor√°rio da avalia√ß√£o: _____________
- Local da avalia√ß√£o: _____________

**N√£o deixem ningu√©m para tr√°s. Se um n√£o sabe, ensinem!**
